<!DOCTYPE html>
<html>
<head>
	<title>Занятие по ФОС</title>
	<meta charset="UTF-8">
	<link rel="stylesheet" type="text/css" href="style/main_style.css"/>
	
</head>

<body>

<h1 class="date">05.02.2015</h1>
<h2 class="theme">Продолжение 04.02.2015</h2>

<p><b>Устройства ввода вывода делятся на два типа:</b> блочные и символьные.
<b>Блочные устройства</b> сохраняют информацию блоками и символами размера. Передают данные блоками.
Блочные устройства - жесткие диски, принтеры, дискеты.
Нам нужно указывать номер блока. </p>


<p>Файлы делятся на кусочки, кусочки записываются в блоки жесткого диска.</p>

<p>Выполняют передачу данных ввиде потока байтов. Сюда относятся мышь, клавиатура и все запоминающие устройства ввода вывода.
Н.: принтеры - <b>символьное устройство.</b></p>


<p>1 способ - это одинарный буфер - эта схема основана на утверждающем вводе или опережающим считыванием. Как только мы записали первый блок считается,
 что следующий блок будет тоже необходим.  мы заранее будем загонять в этот буфер следующий блок данных.  </p>

<p>Двойной буфер - пока в один буфер происходит передача данных от устройства ввода-вывода пользовательский процесс уже считывает информацию из второго буфера.
Затем происходит переключение между буферами.</p>

<p>Бывает и тройной буфер. Наращивание буфера не всегда решает все проблемы.</p>



<ol>
  <li><b>Polling</b>постоянный опрос регистра контроллера. Процессор опрашивает до тех пор пока не будут все регистры заняты.<br>
  <b>Недостатки:</b>процессор постоянно занят либо опрос,либо устройством ввода-вывода.
  </li>
  <li><b>Прерывание</b>- исходит от устройства ввода-вывода. Cвязано с устройствами и функциями.</li>

</ol>

<h2 class="theme">Тема: Дисковое планирование</h2>

<p>
<b>Работа жесткого диска</b> - диск вращается , дисковая головка ищет необходимый цилиндр. Скорость вращения <b>7200</b> оборотов в минуту.
<b>+60</b> раз в секунду. Для процессора- это очень медленное устройство. Существуют разные алгоритмы планирования. Существуют <b>алгоритмы дискового
планирования</b> необходимые для того, чтобы дисковая головка выполняла как можно меньше операций.</p>



<ol>
<caption><b>Основные алгоритмы дискового планирования</b></caption>
<li><b>FIFO</b> <br>
<b>Задача:</b> Пусть на диске имеется <b>200</b> дорожек и головка жесткого диска расположена под номером <b>100</b>.<br>
<code>
<b>1</b>---------------<b>ls</b>-------------><b>100</b><br>
<b>1 2 3 4 5 6 7</b> ----------------<b>200</b> (Наша головка расположена на <b>100</b> дорожке)

</code>
Пусть в очереди находятся запросы к дорожкам с номерами <b>55</b>, <b>58</b>, <b>39</b> , <b>18</b>, <b>90</b> , 
<b>160</b>, <b>150</b>, <b>38</b>, <b>184</b>  - это наша очередь.<br>
   <ol>
     <caption><b>Если мы используем алгоритм FIFO - мы должны обрабатывать запросы попорядку.</b></caption>
	 <li>Мы находимся на <b>100</b> перейти на <b>55</b> --- пересекаем <b>45</b> дорожек</li>
	 <li>
	 от <b>55</b><br>
<b>45</b> + <b>3</b> + <b>19</b> + <b>72</b> + <b>70</b> + <b>122</b> + <b>146</b> / <b>9</b> = <b>55,8</b> <span class="comment"> //средняя продолжительность поиска</span><br>
<span class="comment">//делим на количество переходом</span>
</li>
   </ol>



</li>


</ol>

<!--
Основные алгоритмы дискового планирования:
1)FIFO
Задача: Пусть на диске имеется 200 дорожек и головка жесткого диска расположена под номером 100.  -->



<!-- 1---------------ls-------------> <!--100  -->
<!--1 2 3 4 5 6 7 ----------------200 (Наша головка расположена на 100 дорожке)

Пусть в очереди находятся запросы к дорожкам с номерами 55, 58, 39 , 18, 90 , 160, 150, 38, 184  - это наша очередь
Если мы используем алгоритм FIFO - мы должны обрабатывать запросы попорядку
1) Мы находимся на 100 перейти на 55 --- пересекаем 45 дорожек
2) от 55
45 + 3 + 19 + 72 + 70 + 122 + 146 / 9 = 55,8 //средняя продолжительность поиска
делим на количество переходом   -->




<ol>
<caption><b>Алгоритмы дискового планирования:</b></caption>
<li><b>SSTF</b> ( <b>Short Seek Time First</b>) -выбирает подзапрос на ввод - вывод, который требует наименьшее перемещение головок из текущей позиции.<br>
<b>Н.: </b>мы хотим записать файл разбитый на несколько блоков или считать <b>1</b> файл, который находится в разных блоках мы выбираем тот запрос, который 
находится ближе всего к текущей позиции. Если мы находимся на <b>100</b> позиции переходим к <b>90</b>. Далее ищем следующую ближайшую позицию. и смещаемся на
неё. возвращаемся в центр и идет в другом направлении. В данном алгоритме головка перемещается в двух направлениях.<br>
<code>
<b>55</b>, <b>58</b>, <b>39</b> , <b>18</b>, <b>160</b>, <b>150</b>, <b>38</b>, <b>184</b></code><br>
<span class="comment">какие-то числа ...^)</span></li>
<li><b>SCAN</b><br>
<code>
<b>55</b>, <b>58</b>, <b>39</b> , <b>18</b>, <b>160</b>, <b>150</b>, <b>38</b>, <b>184</b> </code><br>
<span class="comment">теже самые числа ...^)</span><br>
головка перемещается строго в одном направлении, после достижения последней дорожки, головка меняет направление в противоположное направление<br>
<code>
<b>100</b> -- > <b>150</b> --> <b>160</b> --><b>184</b>  --><b>90</b> --><b>58</b> --> <b>39</b> --><b>38</b>--><b>18</b>
</code><br>

<b>SCAN</b> отдает предпочтение тем дорожкам которые находятся ближе к центру. 
Это и <b>плюс</b> и <b>недостаток</b> этого алгоритма. Неполучил широкое распространение.</li>
<li>CSCAN  - проводит циклическое планирование поверхности. Перемещает головку только в одном направлении. когда
доходит до последней головки он начинает сканирование заново.<br>
<code>
<b>100</b> -->  <b>150</b>--><b>160</b> --><b>184</b><span class="comment">(дошли до конца, возвращаемся сначала сканировать по порядку)</span>
--><b>18</b> --><b>38</b> --><b>39</b> --><b>56</b> --><b>58</b>--><b>90</b>
</code>

</li>
</ol>
<p>Обычный <b>scan</b> неэффективный из-за того, что головка перемещается в двух направлениях.</p>

<h2 class="theme">Тема: Файловая система</h2>



<p>Файловые системы (<b>FAT32</b>,<b>NTFS</b>, <b>EX4</b>,<b>EX3</b>  и т.д. <b>~200</b>шт.)</p>


<p class="homeread">!!!Следующее занятие СЕМИНАР(следующая среда)</p>
<ul>
<caption><b>Возможные темы:</b></caption>
   <li>ISO 9660(Juliet, UDF Rock disky)</li>
   <li>ext2/3/4</li>
   <li>Lustre</li>
   <li>GlustorFS</li>
   <li>FAT 12/16/32/exFAT/VFAT</li>
   <li>NTFS, WinFS</li>
   <li>reisorFSO,JFs,XFS</li>
   <li>MooseFS</li>
   <li>Tlvos Nedia FS(STL)</li>
</ul>
<p class="homeread">!!!!!МОЯ FATx - файловая система для игровых консолей</p>
<ol>
<caption><b>Что рассказать в докладе про файловую систему?</b></caption>
<li>физическая организация</li>
<li>архитектура</li>
<li>история</li>
<li>где используется</li>
<li>как она работает</li>
<li><b>Reiser FS</b> (если не найду) про <b>FATx</b></li>
</ol>

<p>
<b>Логические подсистемы ввода вывода</b> - как мы обращаемся смотри рисунок в тетраде
Организовываются базовые подсистемы ввода и вывода.</p>

<p>Стандартный запрос на открытие или создание файла . Открытие () или создание(<b>create</b>)</p>

<p>Поступает к логической подсистеме. Логическая подсистема использует структуру директорий проверяет права доступа и вызывает базовую подсистему 
ввода-вывода для получения. Для получения доступа к блокам файлов после этого файлы считается открытым , а программа получает в свое распоряжение дескриптор
этого файла (<b>handle</b>).</p>
<p><b>Дескриптор</b> - это ссылка на файл в таблице открытых файлов. В ней находятся дескрипторы файлов(ссылки на файлы). Если к моменту открытия файл уже используется 
другим процессом, тогда после проверки прав доступа к файлу может быть организован совместный доступ. </p>




<a href="http://www.stepbystephtml.com/">Сайт для изучения HTML stepbystephtml.com</a>

<p><b>Все файлы разбиваются на блоки</b> - эти блоки записываются в блоки жесткого диска.</p>

<ol>
<caption><b>Размещение файлов на диске способы:</b></caption>
<li>Выделение непрерывной последовательности блоков</li>
<li>Все блоки файла записывать подряд - этот способ не распространен потому что 
внешняя фрагментация(три стратегии куда разместить короткий процесс). Мы не можем организовать
способ незная окончательный размер файла.
<b>Алгоритм сборки мусора</b>(долго, нужно постоянно обновлять таблицу файлов, неэффективно).</li>
<li>Связанный список - теперь мы у каждого файла добавим в каждый блок указатель на следующий файл.каждый блок содержит 
указатель на следующий блок. (см. рис1)


<br>
	<ul>
		<caption><b>Недостатки связанного списка:</b></caption>
		<li>Расходуется лишняя память под указатели</li>
		<li>Деффектный блок.</li>
		<li>Лишние проходы.
		<br>Таких способов много.
		</li>
	</ul>
</li>
<li> Таблица отображения файлов - указатели хранятся не в каждом блоке, а под это выделяется отдельная таблица. Хранится в индексной
таблице файлов(таблица отображения файлов <b>FAT</b> англ. <b>File Allocation Table</b>).</li>

</ol>

<!--
Размещение файлов на диске способы:
1)Выделение непрерывной последовательности блоков
2)Все блоки файла записывать подряд - этот способ не распространен потому что 
внешняя фрагментация(три стратегии куда разместить короткий процесс). Мы не можем организовать
способ незная окончательный размер файла.
Алгоритм сборки мусора(долго, нужно постоянно обновлять таблицу файлов, неэффективно).
3)Связанный список - теперь мы у каждого файла добавим в каждый блок указатель на следующий файл.каждый блок содержит 
указатель на следующий блок. (см. рис1)


недостатки связанных список:
1)Расходуется лишняя память под указатели
2)деффектный блок
3)Лишние проходы
Таких способов много.



4) Таблица отображения файлов - указатели хранятся не в каждом блоке, а под это выделяется отдельная таблица. Хранится в индексной
таблице файлов(таблица отображения файлов FAT англ. File Allocation Table) -->
  

<p>С каждым файлом связанна небольшая таблица, которая называется <b>индексным узлом</b>, которая перечисляет <b>атрибуты</b> и <b>дисковые адреса</b> блоков файлов.
Индексирование поддерживает прямой доступ к файлу без ущерба внешней фрагментации. </p>


<p>Обычно применяется комбинации <b>одноуровневого</b> и <b>многоуровневого</b> индексов. Первые несколько адресов блоков файлов хранятся в индексном узле.</p>


<p><b>Для больших файлов</b>  - необходимо превратить в <b>ссылку на ссылки</b>. </p>



<p><b>Для маленьких файлов</b> -  индексный узел хранит всю информацию.</p>


<p> <b>Для больших файлов</b> - один из адресов индексного узла указывает на блок косвенной адресации, если этого недостаточно тогда используется <b>двойная косвенная адресация</b>, если и этого недостаточно, тогда используется <b>тройная косвенная адресация</b>. </p>

<p><b>Последний раздел</b> - указатель на косвенную адресацию. Если нехватает той таблице ещё одна косвенная 
адресация.</p>


<p><b>Учет свободного и занятого дискового пространства</b>  -
----использование битового вектора <b>Bit vector</b> (битовая карта) - каждый блок представлен одним битом -принимающие значения <b>0</b> или <b>1</b>.
Мы ищем свободное место. Нужно анализировать последовательность ноликов  и едениц.<br>
 <b>1</b>- занятый блок(ставим после записи информации в блок),<br>
 <b>0</b> - свободный блок. <br>
 После записи информации в свободный блок меняем <b>0</b>  на <b>1</b>.<br>
Такой способ используется в <b>apple mac</b>.<br>
<b>Недостаток:</b> чем больше блоков на диске, тем больше памяти будет занимать.<br>
Иногда если битовый вектор становится слишком большим для ускорения поиска в нем его разбивают на регионы и организуют резюмирующие структуры данных, которые содержат сведения о количестве свободных блоков для каждого региона. Чаще использую  <b>смешанный способ связанных списков</b>.Все блоки по <b>4</b>кб. 
Исследования показали что в <b>UNIX</b> <b>85</b>% файлов имеет размер менее <b>8</b>кб и <b>48</b>% менее <b>1</b>кб. В связи с этим решили поделить блоки на блоки меньшего размера. Но данный способ неэффективный.</p>






<ol>
  <caption><b>Структура файловой системы на диске:</b></caption>
  <li>Суперблок.</li>
  <li>Главная файловая таблица.</li>
</ol>



<p>
<b>Суперблок</b> содержит описание файловой системы.
    <ul>
	    <caption><b>Описание файловой системы:</b></caption>
		 <li>Тип файловой системы.</li>
		 <li>Размер файловой системы в блоках.</li>
		 <li>Размер массива индексных узлов.</li>
		 <li>Размер логического блока.</li>
	</ul>
</p>

<p>
<b>Блок</b> - там где хранятся наши данные. Для повышения устойчивости файловых систем обычно хранится несколько копий суперблоков.</p>

<p><b>Главная файловая таблица</b> - это аналог суперблока. В ней хранится вся информация о размере файловой системы. Это хранилище и способ упорядочевание файлов 
на носителе. Строит в определенном порядке в виде дерева. Всю информацию хранят <b>main file table</b> на начальных секторах загрузочного диска. <b>MFT</b> - хранят вторую копию(зеркало)в середине диска. Если мы повредим информацию сбой происходит в конце.</p>


<p>В последней презентации домашка по памяти.</p>



</body>
</html>