<!DOCTYPE html>
<html>
<head>
	<title>Занятие по ФОС</title>
	<meta charset="UTF-8">
<link rel="stylesheet" href="style/main_style.css">

</head>

<body>
<button class="button button-3d button-box button-jumbo" id="menu_content"><i class="fa fa-thumbs-up">Содержание</i></button>
<ul class="main_menu">
	<!--  <caption><b>Содержание:</b></caption>-->
	<!--<li class="table_of_contents"><a href="index.html">Содержание:</a></li> -->
	<li><a href="1)18.12.2014_t.html" class="button button-3d button-primary button-rounded">18.12.2014</a></li>
	<li><a href="2)24.12.2014_w.html" class="button button-3d button-primary button-rounded">24.12.2014</a></li>
	<li><a href="3)25.12.2014_t.html" class="button button-3d button-primary button-rounded">25.12.2014</a></li>
	<li><a href="4)14.01.2015_w.html" class="button button-3d button-primary button-rounded">14.01.2015</a></li>
	<li><a href="5)15.01.2015_t.html" class="button button-3d button-primary button-rounded">15.01.2015</a></li>
	<li><a href="21.01.2015_w.html" class="button button-3d button-primary button-rounded">21.01.2015</a></li>
	<li><a href="8)04.02.2015_w.html" class="button button-3d button-primary button-rounded">04.02.2015</a></li>
	<li><a href="home.html" class="button button-3d button-primary button-rounded">home процессы</a></li>
</ul>
<h1 class="date">14.01.2015</h1>



<ol>
<caption>
<b>Кооперация процессов-</b><br>
Основные причины для объединения усилий процессов:</caption>
	<li>повышение скорости решения задач (пока один процесс ждет события,
другие могут заняться какой-то работой)</li>
	<li>совместное использование данных</li>
	<li>модульная конструкция системы</li>
	<li>для удобства работы пользователя</li>
</ol>


<ol>

<caption><b>Средства обмена информации бывают:</b></caption>
	<li>сигнальные - задается мин. кол-во бит (да или нет)</li>
	<li>канальные - общение происходит через линии связи (общение с помощью записок)</li>
	<li>разделяемая память - могут использоваться в некоторой облсти адресного
пространства</li>
</ol>

<p>созданием памяти занимает ос</p>

<ul> 

<caption><b>Разрешают два способа адресации</b></caption>
    <li><b>прямая адресация</b> - взаимодействующие процессы общаются друг с другом с помощью средств взаимодействия каналов связи. 
Связь бывает сигнальная и канальная. (сигнальная либо да, либо нет), общение - каналы.
при каждой операции обмена данные указывают имя или номер процеса, которому предназначена инфа или от кого инфа идет.</li>
    <li><b>непрямая</b>  -  данные помещаются в некоторый промежуточный объект
в частности в буфер, имеющей свой адрес. Оттуда они могут быть изъяты другим процессом.
Каналы связи могут быть симплексными, полудуплексными и дуплексными.</li>
 
</ul>

<p><b>симплексные</b> - в одну сторону
полудуплексные - в одну сторону</p>
<p><b>дуплексные</b> - одновременно в две стороны могут передаваться</p>

<h3>Буфер может быть разным</h3>
<ol>
<caption>Буферизация 3 варианта:</caption>
	<li>Буфер нулевой емкости - буфер отсутствует инфа не может сохраняться
он переходит в состояние ожидания</li>
	<li>Буфер ограниченной емкости - размер буфера равен n и больше этого объема инфы хранить не может.</li>
	<li>Буфер неограниченной емкости - теоретически это возможно, но практически, это врятли реализуемо.
Процесс ждет своей очереди и приема.</li>
</ol>



<p>Для того, чтобы правильно организовать работу буфера  есть</p>


<ol>
<caption>Две модели передачи данных по каналам связи:</caption>
	<li>поток ввода вывода - поток байтов, которые он воспренимает и интерпретирует</li>
	<li>сообщения</li>
</ol>


<p>поток связи называют трубкой <b>pipe</b>, <b>fifo</b></p>

<p>когда мы отправляет инфу сообщениями вся инфа делится на кусочки фикс. размера
при передачи инфы между процессами , нужно продумать то , что канал связи должен быть надежным</p>


<p><b>нэрзед коды</b> - кодирование по завершению процесса.</p>

<p>Есть у нас сообщение с правильной чек суммой</p>


<ol>
<caption>программа:</caption>
	<li>ожидание ввода <b>А</b></li>
	<li>ожидание ввода <b>В</b></li>
	<li>ожидание ввода <b>С</b></li>

</ol>
<p>
ввести массив <span class="formula">А</span><br>
<span class="formula">А= А+В</span><br>
<span class="formula">С=А+С</span><br>
<span class="formula">вывести массив С</span><br>
<span class="formula">Ожидание вывода С</span>
</p>

<p><b>Нити исполнения</b> - это процессы, одного процесса.<br>
Нить 1  должна создать 2 нить.<br>
нить помощника для исполнения задания
между нитями есть нить переключения контекста. Нить 2.
Нить А и Б.</p>

<p>Пусть нить 1 <br>
Ввести нить А.<br>
в это время вторая нить цже посчитает сумму А и Б.<br>
Пока она считает возвращаемся к первой.<br>
переключения контекста в некоторых случаях мы можем только выиграть</p>


<p>Различают Ос поддерживающие нити на уровне ядра и на уровне библиотек.
Мало ОС , которые поддерживают функции на уровне библиотек.
(блокирование 1 нити приводит к блокированию всех нитей)
алгоритмы синхронизации - <b>interleaning, race condition.</b></p>


<p>Активность действия, которые нужно выполнить для получения результата
(определенной цели). могут быть как в программе, так и в жизни людей.
Активности бывают <b>делимые</b> и <b>неделимые.</b>
Состоят из операций <b>делемых</b> и <b>неделимых.</b><br>
неделимые называются -<b>(атомарные)</b>
Активность   P с операциями и активность B.
При выполнении они могут чередоваться.<br></p>
<p>
<b>Чередование</b> - это interleaning

<ol>
	<li>активность состоит из операция A B C</li>
	<li>активность из D E F</li>
</ol>
</p>
<p>
Не всегда нам выгодно чередование, иногда нам необходим один и тот же  результат.
Если у нас операции не будут чередоваться 1 2</p>


<p>
<span class="formula">
P:x=2 Q:x=3</span><br>
<span class="formula">y=x-1</span>
<span class="formula"> y=x+1</span>

<br>
<span class="formula">(xy):(2,1)(3,4)
</span>


<span class="formula">(xy): (2,3),(3,2)</span>
</p>
<p>Детерменирован набор всякий раз при псевдопараллельном исполнении
для одного и того же набора входных данных дает одинаковые выходные данные.
В противном случае такой набор называется недетерменированным.</p>


<p>При недетменированном наборе программ, говорят что он не<b> race condition</b>
состояние гонки и состояние состязания.</p>


<p><b>механизм взаимоисключения</b>- если 1 получил доступ , другой получить доступ не  может
Критические секции - суть состояит в том, что если я получила доступ к каким-то ресурсам я блокирую 
доступ к этим ресурсам. другие ресурсы ожидают освобождение ресурса.</p>


<p>часть программы исполнение которойможет привести к возникновению race condition для определенного набора программ, чтобы исключить эффект фона
какому-то ресурсу необходимо организовать работу так, чтобы в каждый момент времени
только один процесс мог находиться в своей критической секции связанной с этим ресурсом
Критическую секцию можно описать с помощью цикла </p>


<p>
<code>

while(some condition) {<br>
 &ensp;  entry section;<br>
 &ensp;  crition section;<br>
   &ensp; exit section;<br>
<br>
<br>

   &ensp;remainder section;<br>
}
</code></p>
<p>
результат всегда будет один и тот же
</p>




<p>программные алгоритмы организации взаимодействия процессов:
мы отправляем прерывание
</p>


<ol>
	<li>
алгоритм - <b>"запрет прерывание"</b><br>
<code>while (some condition) {<br>
&ensp; 	запрещать section;<br>
&ensp; 	разрешить прерывание;
<br>
&ensp; 	remainder section;<br>
}</code><br>

если значение замка 1 - ждем пока значение не станет 0.

</li>
	<li>
алгоритм - <b>"переменная замок"</b>
shared int lock=0.<br>
Если процесс протестировал процесс lock<br>
Все операции должны быть атомарными.<br>
<br>
Флаги готовности<br>
<span class="formula">shared int ready[2] = {0,0}</span>
<br>
Как i процесс готов войти в критическую секцию он меняет на 1.<br>

</li>
</ol>


<p>флаги готовности , когда i - ый процесс, готов войти в критическую секцию, он присваивает ready i - значение равное 1, после выхода он сбрасывает значение в 0.
Процесс не сбрасывает, если он уже готов.</p>

<p>
<code>
while(some section){<br>
  &ensp;   ready[i] = 1;<br>
&ensp; &ensp; 	while(ready[i+1]);<br>
&ensp; &ensp; 	critied section;<br>
&ensp; &ensp; 	ready[i] =0;<br>
&ensp; &ensp; 	remainder section;<br>
<br>
}<br>

</code>
</p>
<p>
<code>
while(some section){<br>
&ensp;     ready[i] = 1;<br>
&ensp; &ensp; 	while(ready[i+1]);<br>
&ensp; &ensp; 	critied section;<br>
&ensp; &ensp; 	ready[i] =0;<br>
&ensp; &ensp; 	remainder section;<br>

}<br>
</code>

</p>

<p>пусть процессы одновременно произошли к выполнению пролога, после выполнения присваивания планировщик передал процессор
такая ситуация называетя <b>тупиковой</b> или <b>d=0</b><br>
1 процесс не может ввойти, потому что другой ждет они будут бесконечно долго друг друга ждать такая ситуация называется <b>тупиковой.</b></p>

<!--



				Процесс А	< -----Deadlock----- >	Процесс В
						|		    |
						|		    |
						V         	    V
						Ресурс 1 	Ресурс 2

--->
<p>
Одна тупиковая ситуация может привести к зависанию тупиковой ситуации.
Множество процессов находится в тупиковой ситуации.
</p>

<h1 class="nb"> 18-19 февраля экзамен по ФОС.</h1>

<p>
Множество процессов находятся в тупиковой ситуации , если каждый процесс ожидает событие, которое может вызвать
только друго процесс данного множества, т.к. оба процесса ожидают они не смогут уступить (зависание)</p>
<p></p>
<p></p>

<ol><caption><b>Условия возникновениятупиков:</b></caption>
	<li>Условие взаимоисключения - т.е. одновременно один и тот де ресурс может использовать только один процесс,
Мы используем взаимоисключения для того, чтобы не возникло состояний гонки.</li>
	<li>Условие ожидания ресурсов - hold and wait процесс вытается запрашивать другой ресурс</li>
	<li>Условие неперераспределяемости -<b>no preemtion</b> </li>
<li>Условие кругового ожидания
круговое ожидание - освобождение ресурсов другими процессами.</li>
</ol>
<h1 class="nb">!!!КНИЖКА КАРПОВА (ПРИМЕР С ПИВОМ по ФОС)</h1>
<ol>
	<caption>Основные направления борьбы с тупиками:</caption>
	<li>Игнор проблемы (свернуть, запустить заново)</li>
	<li>предотвращение тупиков (алгоритм банкира)</li>
	<li>восстановление тупиков</li>
	<li>.....?</li>
</ol>


<ul> 
<caption>Способы предотвращения:</caption>
    <li>алгоритм банкира</li>

</ul>

<p>Безопасное состояние, которое не приведет к взаимоблокировке.
Пример надежного состояния для системы с 3 пользователями:
текущая ситуация такова,</p>




<table>
<tr>
<th>Макс передача раздача</th>
</tr>
<tr>
<td></td>
<td>макс.<br>потребность</td>
<td>Ради<br>ресурсов</td>
</tr>
<tr>
	
<td>1</td>

<td>9</td>

<td>6</td>

</tr>

<tr>
	
<td>2</td>

<td>10</td>

<td>2</td>

</tr>
<tr>
	
<td>3</td>

<td>2</td>

<td>3</td>

</tr>
</table>

<!--
       макс.     Ради
    потребность  ресурсов

1	9	6
2	10	2
3	3	2

-->
мы можем поделиться ресурсами сначало с 3
Мы должны доверять клиентам, чтобы доверять процессы.

Способы предотвращения обнаружение тупиков
<!--
<p>
<b>ГРАФ </b>- это 0


	P2---->R1---->R3
	^	      |
	|	      |
	|	      V
____	|	      R3
|P4| -->P2	      |
----	^	      |
	|	      V		      V
	<-------------R5
-->


<p><b>P </b>- процесс</p>
<p><b>R </b>- ресурс</p>
<p><b>R1</b>ждет пока <b> lock=0</b> </p>
<!--
P - процесс
R - ресурс
R1 ждет пока lock=0    -->
<p>Тупиковые ситуации можно обнаруживать с помощью построения графов.
</p>


<p>самый простой способ выйти из тупика - <b>убить процесс.</b></p>

<p>Завтра мы будем проходить симафоры (алгоритм обедающего философа)<br>
<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_%28%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0%29">
семафоры</a>
</p>

<p>Завтра мы будем проходить симафоры (алгоритм обедающего философа)</p>





</body>
</html>



