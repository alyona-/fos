<!DOCTYPE html>
<html>
<head>
	<title>Занятие по ФОС</title>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="style/main_style.css">
</head>

<body>
<button class="button button-3d button-box button-jumbo" id="menu_content"><i class="fa fa-thumbs-up">Содержание</i></button>
<ul class="main_menu">
    <!--  <caption><b>Содержание:</b></caption>-->
    <!--<li class="table_of_contents"><a href="index.html">Содержание:</a></li> -->
    <li><a href="1)18.12.2014_t.html" class="button button-3d button-primary button-rounded">18.12.2014</a></li>
    <li><a href="2)24.12.2014_w.html" class="button button-3d button-primary button-rounded">24.12.2014</a></li>
    <li><a href="3)25.12.2014_t.html" class="button button-3d button-primary button-rounded">25.12.2014</a></li>
    <li><a href="4)14.01.2015_w.html" class="button button-3d button-primary button-rounded">14.01.2015</a></li>
    <li><a href="5)15.01.2015_t.html" class="button button-3d button-primary button-rounded">15.01.2015</a></li>
    <li><a href="21.01.2015_w.html" class="button button-3d button-primary button-rounded">21.01.2015</a></li>
</ul>
<h1 class="date">15.01.2015 (четверг)</h1>

<p>Для того, чтобы не было тупиковых ситуаций race condition придумали<br>
<b>mutex</b><br>
Ни процец П1 ни П2 не исполнится, так как у них одни и те же ресурсы. </p>



<p><b>Алгоритм банкира </b>- после того как один процесс используется он освоюождает ресурс, 
банкир должен быть уверен в том что процес вернет ресурс,
Если возникает тупиковая ситуация, тогда необходимо убить ресурс.</p>


<h1>Семафоры, мониторы и очереди сообщений.(Semaphores, monitor, messages)/
Семафоры проверяют свободны ли наши ресурсы.</h1>


<p><b>Критическая секция</b> - закрытие ресурса ,если ресурс занят.
Если ресур занят закрываем семафор.
Можно в семафоре установить значение 500, если он свободен.
Как только документ устанавливается мы сбрасываем значение семафоров.</p>


<p>Семафор указывает на входе двери ресурс занят или ресрс свободен
или он заполнен на половину и может принять сколько то процессов.</p>


<p><b>Семафоры</b> - это целая разделяемая переменная с неотрицательными 
значениями,доступ любого процесса к которой может осуществляться
только через две атомарные операции. P - proberen - проверять
V-verhogen - увеличивать (от датских слов)</p>

 <p><b>(P,S)</b></p>


<p><b>P(S)</b> - пока s=0 процесс блокируется; S=S-1 - процесс блокируется</p>

<p>При выполнении операции P над семафором S сначало проверяетя его значение,
если оно больше 0, то из s=s-1 , если оно меньше или равно нулю,
то процесс блокируется до тех пор, пока S - не станет больше 0.</p>

<p>После чего из S вычитается 1, при выполнении операции V (увеличении)
над семафором (S)  к его значению просто прибавляется 1.</p>

<p>
в момент создания семафор может принимать любое не отрицательное значение.
Процесс , когда подходит к критической секции он проверяет значение семафора.</p>


<p>Семафоры встроены на все операционные системы. В некоторые Ос они встроены в синтаксис.
решение проблемыили решение задачи <b>(производитель - потребитель)</b>
producer-consumer (производитель потребитель)</p>

<p>процессы обмениваются инфо, они могут использовать для них буфер.</p>


<p>
Задача писателя-читателя</p>

<p>Пусть два процесса обмениваются информацией через буфер.
Буфер ограниченного размера.</p>

<p>Производитель закладывает инфу в буфер , а потребитель считывает эту инфу из буфера.</p>

<p>

<b>Producer</b><br>
<code>
while(1) {
    produce item;
    fn1, item
    
}
consume
      while(1) {
      get item
      consume item
 }</code>

</p>

<p></p>
<p></p>
<p></p>















<p>Буфер ограниченного размера мы не может туда записывать информацию.
потребитель, если буфер пуст потребитель должен ждать пока туда запишуь
какуе-то инфу.</p>


<p><b>Как эта задача решает с помощью семафоров?</b><br>
Возьмем 3 семафора:<br>
<b>Cемафор empty</b> - производитель записывает инфу только тогда, 
когда буфер свободен.<br>
<b>Семафор fn1</b>  - будем использовать для организации ожидания производителя
при заполненном буфере.<br>
<b>Семафор full</b> - будем использовать для гарантии того , что потребитель
 будет ждать пока в буфере появится информация.<br>
<b>Семафор mutex</b> - для организации взаимоисключения 
на критических участках.<br>
В данном случае участки - это <b>put item</b> и <b>get item</b>.<br>
 </p>






<p><b>Взаимоисключения</b> - механизм , которых используется для того чтобы два ресурса
не стали состязаться за ресурс, а использоваться в необходимое для каждого время.</p>


<p>Пока P(s):S==0, блок;
S=S-1;
V(S):S=S+1
O<-(1) </p>
<p>
P - проверка семафора V- действие над семафором (увеличение над семафоров)
Semaphor mutex = 1; //т.е. ресурс свободен, буфер пуст - то что произ
изводитель ожидает пока освободиться буфер
semaphor empty =N; 
semaphor full=0; </p>

<p>
<code>
Producer: <span class="comment">//(записывает инфу)</span> <br>
 &nbsp;    while(1){ <br>
&nbsp;	produce item;<br>
&nbsp;	P(empty);<br>
&nbsp;	P(mutex)<br>
&nbsp;	putt item  <span class="comment">//наложить</span><br>
&nbsp;        v(mutex) <span class="comment">//увеличиваем mutex</span><br>
&nbsp;	v(full) <span class="comment">//увеличиваем full</span><br>
	
}
</code>
</p>
<p>
consumer//(считывает)
     while(1){
     P(full)
     P(mutex)
     get item
     v(mutex)
     V(empty)  //как только буфер освободиться
     //записать туда информацию

}</p>
<p>
P означает действие семафора s=s-1
v - увеличиваем ресурс , S- освобождает </p>


<p>Семафор может быть не только двоичный.
Если ресурс либо занят либо свободен, он может иметь только два состояния. </p>


<p>consumer - следит за семафорами, проверяет их на свободу.
есть процесс producer, есть процесс consumer.<br>

Чтобы не возникло конфликтов мы блокируем критическую секцию, наш ресурс
это наш буфер.</p>




<p>
Семафор в Linux -это модуль ядра, они подключают библиотеки,
их пишут на assembler
т.е. в винде мы все прописываем самостоятель и управляем ими,
в линуксе подключаем библиотеку.</p>

<p>
asm/semafore - подключаем библиотеку
все фигня прописана в библиотеки семафор в линуксе
это типа как прописано инициализация в библиотеки
псевдокод для линукса
down - добавляем 1
up - увеличиваем
void sema_init(strint, semainit)
используется алгоритм fifo (кто первый пришел, тот
 и использует ресурс).</p>


<p><b>Аппаратная реализация семафоров</b> - (запрет прерываний, прерывания, замок).</p>

<h2 class="theme">Часть 2. Монитор</h2>

<p><b>Монитор</b> - механизм синхронизации, совокупность процедур
предназначенная для управления ресурсами определенного типа.</p>

<p>Монитор отвечает за распределение ресурсов, а также контролирует
обращение к ним со стороны различных программ. Он полностью отвечает
за те ресурсы, которые ему выданы. Это тоже механизм организации
параллелизма, который содержит данные и процедуры необходимые 
для динамического распределения какого-либо общего ресурса или
группы общих ресурсов. Чтобы обеспечить выделение необходимого ресурса
процесс должен обратиться к конкретной процедуре монитора.
Если ресурс занят, то монитор выдает команду wait и процесс,
который пожелал войти в монитор должен ожидать вне монитора освобождение этого монитора.</p>

<p>Тогда процесс пожелавший войти в монитор должен ожидать вне монитора.
Процесс, который пожелал войти в монитор ожидает его освобождения.</p>

<p>wait<br>
signal</p>

<p><b>Монитор</b> - набор процедур.<br>

Некоторый процессы могут выйти из монитора не выполнив все процедуры
до конца.
Те процессы, которые побывали в мониторе ОС ставит их в отдельную очередь.
Очередь - уснувшие процессы.
Когда монитор освободиться в следующий раз, он просматривает очередь
уснувших процессов.</p>

<p>wait(имя, условие)<br>
signal(имя, условие)</p>

<p>Команда wait выполнятся движением запрещенных прерываний и уменьшает содержимое 
счетчика на 1.
 Если счетчик меньше 0, то процесс помещается в очередь
ожидающих открытие этого монитора и процессор освобождается от этого монитора.
Процессор освобождается от этого процесса.</p>

<p>signal -работает в режиме запрещенных прерываний.
как только процесс освободился он выбирает из очереди и уменьшает значение счетчика.
На абстрактном уровне можно описать структуру мониторого таким образом. </p>

<p><code>
monitor monitor_name {<br>
&nbsp;	описание внутренних переменных<br>
&nbsp;	void m1()<br>
&nbsp;	void mn<br>
&nbsp;	блок инициализации внутренних переменных<br>

}</code><br>
m1, m2,...,mn - это функции-методы монитора</p>

Блок инициализации внутренних переменных содержит операции,
которые выполняются тольк один раз. Либо при создании монитора,
либо при самом первом вызове функции и метода монитора.

В задаче produce consume - тоже применимы мониторы.
параллельный эвклид и параллельный паскаль

эмуляция монитора с помощью системных вызовов для обычных
языков программирования. которые широко распространены не так проста,
как эмуляция семафора, поэтому в некоторых случаях мониторы 
применяются в ОС.

Адресация прямая и косвенная

Сообщения - механизм синхронизации (также как семафоры и мониторы)


Для примеров адресации достаточно описать два типа - это приметивы для описания передачи
 сообщения процессам по линии связи.
send(p, message) //послать сообщение message процессу p
receire(0,message)
в случа не прямой адресации нам нужен ящик куда мы будем отправлять сообщения
send(A, message)//отправить сообщение в ящик А
receire(A,message)//получить сообщение из ящика А

В сообщениях более проста реализая, но передача происходит по более высокоуровнемым организациям.
Они между собой эквивалентны. выполняют одну и ту же функцию.
Их реализуют мониторы с помощью передачи сообщений.

Часть 3. Диспечиризация в ОС:
За управление процессами отвечают определенные менеджеры
Диспетчер - это программа ОС , которая рпинимает решение 
о том, какой процесс должен быть запущен в данный момент.
и устанавливает машинный счетчик команд, которые содержат адрес следующей
выполняемой проги.(команды)
Что делает менеджер управления процессами?
Блок управления процессами или подсистема управлния процессами.
менеджер раздает процессору в распоряжение время.
планировщик работает с определенным алгоритмом планирования.
сможет ли боле приоритетное время вытеснить выполняемую задачу.
Если мы его сможем вытеснить мы должны выполнить прерывание, установить занятость
процесса. выкинутый процесс мы ставим в очередь. он переходит в состояние
готовности.
----контекст процессора - жрунал в котором хранится инфа о
состоянии ОС.
---дескриптор - хранит информацию о состоянии процесса.
(типа паспорт у чела:) )

в регистре тоже записываются состояния программы. Дескриптор - описывает
именно сам процесс, динамическая таблица.

 Сохраняет информацию предсмртную записку.
Процесс с таким-то номером убил другой.

В каких случаях управление передается диспетчеру.
случаи:
1)Выполняющаяся программа отказывается от управления и выдает команду
wait, блокируя свое выполнение или просто отдает управление системе.
2)Когда некоторый системный механизм определяет невозможность выполнения
проги, блокирует её и обращается к диспетчеру с требованием запустить другую программу.
3) Происходит прерывание по времени сообщающее об истечении кванта времени для задачи
4)Одно из ранее заблокированных заданий переводится в состояние готовности и 
у диспетчера возникает необходимость проверить ту задачу, которая имеет более высокий приоритет



В следующий раз проведут контрольную работу по процессам
по базовым понятия
рассказать о жизненном цикле процесса и описать коротко.


</body>
</html>
