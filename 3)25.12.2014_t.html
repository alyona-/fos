<!DOCTYPE html>
<html>
<head>
	<title>Занятие по ФОС</title>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="style/main_style.css" />
</head>

<body>
<button class="button button-3d button-box button-jumbo" id="menu_content"><i class="fa fa-thumbs-up">Содержание</i></button>
<ul class="main_menu">
	<!--  <caption><b>Содержание:</b></caption>-->
	<!--<li class="table_of_contents"><a href="index.html">Содержание:</a></li> -->
	<li><a href="1)18.12.2014_t.html" class="button button-3d button-primary button-rounded">18.12.2014</a></li>
	<li><a href="2)24.12.2014_w.html" class="button button-3d button-primary button-rounded">24.12.2014</a></li>
	<li><a href="3)25.12.2014_t.html" class="button button-3d button-primary button-rounded">25.12.2014</a></li>
	<li><a href="4)14.01.2015_w.html" class="button button-3d button-primary button-rounded">14.01.2015</a></li>
	<li><a href="5)15.01.2015_t.html" class="button button-3d button-primary button-rounded">15.01.2015</a></li>
	<li><a href="21.01.2015_w.html" class="button button-3d button-primary button-rounded">21.01.2015</a></li>
	<li><a href="8)04.02.2015_w.html" class="button button-3d button-primary button-rounded">04.02.2015</a></li>
</ul>
<h1 class="date">25.12.2014</h1>

		<h2>Алгоритмы планирования</h2>
<p>Работа алгоритма планирования зависит от используемой функции выбора</p>


<ol>
<caption>Три величины:</caption>
	<li>Время затраченное системой</li>
	<li>время затраченное на исполнение</li>
	<li>Общее время обслуживания, требующееся процессору (сколько времени требуется затратить на обработку процесса).</li>
</ol>

<ul> 
<caption>Режим решения подразделяют на две категории, в которой могут работать алгоритмя планирования </caption>
    <li>Вытесняющие</li>
    <li>Не вытесняющие (пока процессор полностью не обработает процесс, он 
никуда не уйдет)</li>
</ul>
<p>
<b>first Come, first served (FCFS)</b>- алгоритмы планирования - первый пришел первым обслужился.
Это невытесняющее планирование - процесс, получивший в свое распоряжение процессор, занимает его до истечения своего текущего
cpu burst(промежут времени непрерывного использования процессора).<br>
<b>I/O (input/output)</b>-промежуток ожидания ввода вывода</p>

<p>a=1<br>
b=2<br>
read c  cpu burst</p>

<p>ожидание <br>
ввода</p>

<p>a=a+c+b<br>
print</p>

<p>Время входа в систему<br>
Процесс<b> А </b>на<b> 5 </b>еденице<br>
Процесс<b> В </b>на 1 секунде<br>
Процесс<b> С </b>на<b> 3 </b>секунде</p>

<p><b>CPU:100,400,1,4 (процессы)</b></p>

<p>a=5<br>
b=1<br>
c=3</p>

<table>
<tr>
	<td>1</td>
	<td>2</td>
	<td>3</td>
	<td>4</td>
	<td>5</td>
	<td>6</td>
	<td>7</td>
	<td>8</td>
	<td>9</td>
</tr>

<tr>
	<td class="shtrih">1</td>
	<td class="shtrih">2</td>
	<td class="shtrih">3</td>
	<td>4</td>
	<td>5</td>
	<td>6</td>
	<td>7</td>
	<td>8</td>
	<td>9</td>
</tr>

<tr>
	<td>1</td>
	<td>2</td>
	<td>3</td>
	<td class="shtrih">4</td>
	<td class="shtrih">5</td>
	<td class="shtrih">6</td>
	<td class="shtrih">7</td>
	<td class="shtrih">8</td>
	<td>9</td>
</tr>

<tr>
	<td>1</td>
	<td>2</td>
	<td>3</td>
	<td>4</td>
	<td>5</td>
	<td>6</td>
	<td class="shtrih">7</td>
	<td>8</td>
	<td>9</td>
</tr>
</table>
<!--
1  2  3  4  5   6  7  8  9
_______
   3	_______________
		5
			___
			 7
 -->
 <ul> 
    <li><b>Преимущества</b> - простота реализации</li>
    <li><b>Недостатки</b>
		<ul> 
			<li>среднее время ожидания</li>
			<li>среднее время выполнения <br>
			зависят от порядка расположения процессов в очереди
при наличии процессов длительных машин, короткие процессы, которые пришли в состояние ожидания.
После рождения переходят в состояние готовности(исполнения).<br>
Короткие процессы будут ожидать состояния готовности.
Такой алгоритм не применим для систем разделения времени.			
			
			</li>
		
		</ul>
	</li>

</ul>


--
--



	<p>	<b>Алгоритм Round Robin(круглая карусель)</b>
процессы подсаживаются на некую карусель (рис.2) </p>
<p>
Рис. 2 <br>

<img alt="рисунок 2" src="img/2.png">
</p>
<p>
Пусть у нас есть процессы <span class="formula">p0, p1, p2</span><br>
Пусть<span class="formula"> p0 = 13</span><br>
      <span class="formula">p1 =4</span><br>
     <span class="formula"> p2=1</span> </p>
 <!--время  | 1  2  3  4  5   6  7  8  9  10   -->

<table>
<tr>
  <th>Время </th>
  
  <td>1</td>
  <td>2</td>
  <td>3</td>
  <td>4</td>
  <td>5</td>
  <td>6</td>
  <td>7</td>
  <td>8</td>
  <td>9</td>
  <td>10</td>
</tr>
</table>
<!--
P0	И  И  И  И  Г(4)

p1		      И  И  И  И  Г	

p2				    И  И  И  И -->


<table>
<tr>
<th></th>
	<th>1</th>
	<th>2</th>
	<th>3</th>
	<th>4</th>
	<th>5</th>
	<th>6</th>
	<th>7</th>
	<th>8</th>
	<th>9</th>
	<th>10</th>
</tr>
<tr>
   <th>p0</th>
   
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   
   <td></td>
   <td></td>
   <td></td>
   <td></td>
   <td></td>
   <td></td>
</tr>

<tr>
<th>p1</th>

<td></td>
   <td></td>
   <td></td>
   <td></td>
   
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">Г</td>
   <td></td>
   <td></td>
</tr>

<tr>
	<th>p2</th>
	
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	
	<td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td></td>
</tr>

</table>

<p><b>Round robin (4)</b></p>

<table>
<tr>
<th>Время </th> <td> 1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td>
</tr>
<tr>
<th>P0</th>	<td>И</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td> 
<td>Г</td><td>ГИ</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td>
</tr>
<tr>
<th>p1</th><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td>
<td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td>
</tr>
<tr>
<th>p2</th><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>ГИ</td><td>Г</td> 
<td>Г</td><td>И</td><td>Г</td><td>Г</td>
</tr>
</table>
<p><b>Round robin (1)</b></p>


<h1>Алгоритм (SJF) Shortest Job RR First</h1>
<p><b>Невытесняющий</b><br>
<!--
Время    | 1  2  3  4  5   6  7  8  9  10
P0

p1 Г Г Г Г И И И И И

p2 Г И И И

p3 Г Г Г Г Г Г Г Г Г -->
<table>
<tr>
<th>Время</th><td> 1</td> <td>2</td>  <td>3</td>  <td>4</td>  <td>5</td>
   <td>6</td>  <td>7</td>  <td>8</td>  <td>9</td>  <td>10</td>
</tr>
<tr>
<th>P0</th>
</tr>
<tr>
<th>p1</th> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>И</td> <td>И</td> <td>И</td> <td>И</td> <td>И</td>
</tr>
<tr>
<th>p2</th> <td>Г</td> <td>И</td> <td>И</td> <td>И</td>
</tr>
<tr>
<th>p3</th> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td>
</tr>
</table>

</p>
<p>
<b>Быстрый алгоритм</b><br>
При невытесняющем планировании процессор предоставляется избранному процессу на све требующееся ему время независимо от событий в системе.</p>


<p>
учитывается появление новых процессов во время выбранного процесса.<br>
Если cpu нового процесса меньше, чем остаток cpu burst исполняющегося, то испол. процесс вытесняется новым.</p>
<h2>Алгоритм работы первой момент появления в очереди</h2>
<table>
<tr>
 <th> (SJF)</th> <td>0</td>  <td>1</td> <td>2</td>  <td>3</td>  <td>4</td>  <td>5</td>   <td>6</td>  <td>7</td>  <td>8</td>  <td>9</td>  <td>10</td>
  </tr>
  <tr>
<th>P0</th> <td>6</td>  <td>5</td> <td>И</td> <td>Г</td> <td>Г</td> <td>Г</td>
</tr>
<tr>
<th>P1</th> <td>2</td>	<td>2</td>	      <td>И</td>  <td>И</td>
</tr>
<tr>
<th>P2</th> <td>5</td>	<td>8</td>
</tr>
<tr>
<th>P3</th> <td>5</td>	<td>0</td>		     <td>И</td> <td>И</td> <td>И</td> <td>И</td> <td>И</td>
</tr>
</table>
<p>
ТИ время нахождения И-того пользователя в системе<br>
Тау и-тое суммарное процессорное время процессов и-того пользователя<br>
Если тау и-тое меньше и-тое деленное на Н<br>
пользователь обделен<br>
если тау и-тое больше чем т и-тое деленное на н<br>
т-итое умноженное на н<br>
На исполнение выбираются готовые процессы пользователя с наименьшим коэффициентом справедливости. Такой алгоритм сложен</p>
<p>
3)<b>Алгоритм приоритетное планирование</b> - каждому процессу в  процессор
выделяется соответствие с приписынамым к нему числовым значением приоритетом. Параметры для назначения приоритета ббывают внешние и внутренние.</p>
<h1>Политика изменения приоритетов бывает : статическая и динамическая.</h1>

<p><b>Статический приоритет</b> - мы его назначили и неизменяем.</p>

<!--
	CPU	момент появления	Приоритет
P0	6		0		4	
P1	2		2		3
P2	5		6		2
P3	5		2		1
-->

<table>
<tr>
	<td>CPU	момент появления</td>	<td>Приоритет</td>
	</tr>
<tr>	
<th>P0</th>	<td>6</td>		<td>0</td>		<td>4</td>	
</tr>
<tr>
<th>P1</th>	<td>2</td>		<td>2</td>		<td>3</td>
</tr>
<tr>
<th>P2</th>	<td>5</td>		<td>6</td>		<td>2</td>
</tr>
<tr>
P3	5		2		1
</tr>

</table>

<table>
	<tr>
		<th><b>P0</b></th><td></td><td></td><td></td><td></td><td></td><td></td><td></td>
	</tr>
	<tr>
		<th><b>P1</b></th><td>И</td><td>И</td><td></td><td></td><td></td><td></td><td></td>
	</tr>
	<tr>
		<th><b>P2</b></th><td></td><td></td><td>И</td><td>И</td><td>И</td><td>И</td><td>И</td>
	</tr>
	<tr>
		<th><b>P3</b></th><td>И</td><td>И</td><td>И</td><td>И</td><td>И</td><td></td><td></td>
	</tr>
</table>
<!--
P0
P1	ИИ
P2	  ИИИИИ
P3ИИИИИ -->

<p>Находится в состоянии готовности
многоуровневые очереди<b>(multi level)</b>
рис.3</p>
<ul>
	<li>системные процессы с приоритетом <b>0</b> с алгоритмом <b>Round Robin</b></li>
	<li>процессы преподавателя с приоритетом <b>2</b> с алгоритмом <b>round robin</b></li>
	<li>фоновые процессы с приоритом <b>3</b> с алгоритом <b>fcfs</b></li>
	<li>процессы студентом с приоритом <b>4</b> с алгоритмом <b>rr</b></li>

</ul>



<p>многоуровневые очереди с обратной связью
очередь, алгоритм, приоритет.
Каждый процесс будет в своей очереди.
Для полного описания требуют
Количество очередей в состоянии готовность
Должен быть общий алгоритм между очередями</p>


<p><b>алгоритмы планирования внутри очередей</b>
Нужно задать куда поместить родившийся процесс и правила перевода процесса из одной очереди в другую</p>


<ul>
	<caption><b>Уровни планирования процессов:</b></caption>
	<li><b>Долгосрочное планирование</b> - это планирование заданий</li>
	<li><b>Среднесрочное планирование</b> - это <b>swapping</b></li>
	<li><b>Краткосоровное планирование</b> - это использование процессов</li>
</ul>


<ol>
	<caption><b>Цели планирования:</b></caption>
	<li><b>Справедливость</b> - гарантировать каждому заданию, каждому процессу некоторую часть процесса.</li>
	<li><b>Эффективность</b> - </li>
	<li>Сокращение полного времени выполнения <b>general time</b>

		время от старта процесса до самого его завершения</li>
	<li>Сокращение времени ожидания</li>
	<li> Сокращение времени отклика <b>(response time)</b></li>
</ol>



<ol>
	<caption><b>Свойства алгоритмов планирования:</b></caption>
	<li><b>Предсказуемость</b> - одно и то же задание должно выполняться приблизительно за одно и то же время</li>
	<li><b>Минимальные накладные расходы</b> - сокращение времени работы самого алгоритма планирования</li>
	<li><b>Сбалансированная загрузка ресурсов системы</b> спреподчтением процессов, которые будут занимать малоиспользуемые ресурсы</li>
	<li><b>Маштабируемость</b></li>
</ol>




<h2 class="homeread">Домашнее задание :</h2>
<p>
	нарисовать графики выполнения процессов по алгоритму по каждому алгоритму

	написать свою программу, которая это реализует.<br>
	<b>fcfs</b><br>
	процессов четыре<br>

</p>


<table>
	<tr><th><b>P0</b></th><td>7</td></tr>
	<tr><th><b>P1</b></th><td>2</td></tr>
	<tr><th><b>P2</b></th><td>9</td></tr>
	<tr><th><b>P3</b></th><td>12</td></tr>
</table>


<!--
     
P0 7
P1 2
P2 9
P3 12 -->
<p>
	<b>round robin</b> с квантом времени (3)<br>
	<b>SJF</b>(невытесняющий)<br>

	<b>SJF (3 0 1 2 )</b>время выполнения<br>
	<b>SJF (1 2 3 4)</b><br>

	продолжительность <b>cpu 7 2 9 12</b><br>

	4) сокращение времени ожидания
</p>





</body>
</html>



