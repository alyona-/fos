<!DOCTYPE html>
<html>
<head>
	<title>Занятие по ФОС</title>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="style/main_style.css" />
</head>

<body>
<button class="button button-3d button-box button-jumbo" id="menu_content"><i class="fa fa-thumbs-up">Содержание</i></button>
<ul class="main_menu">
	<!--  <caption><b>Содержание:</b></caption>-->
	<!--<li class="table_of_contents"><a href="index.html">Содержание:</a></li> -->
	<li><a href="1)18.12.2014_t.html" class="button button-3d button-primary button-rounded">18.12.2014</a></li>
	<li><a href="2)24.12.2014_w.html" class="button button-3d button-primary button-rounded">24.12.2014</a></li>
	<li><a href="3)25.12.2014_t.html" class="button button-3d button-primary button-rounded">25.12.2014</a></li>
	<li><a href="4)14.01.2015_w.html" class="button button-3d button-primary button-rounded">14.01.2015</a></li>
	<li><a href="5)15.01.2015_t.html" class="button button-3d button-primary button-rounded">15.01.2015</a></li>
	<li><a href="21.01.2015_w.html" class="button button-3d button-primary button-rounded">21.01.2015</a></li>
</ul>
<h1 class="date">25.12.2014</h1>

		<h2>Алгоритмы планирования</h2>
<p>Работа алгоритма планирования зависит от используемой функции выбора</p>


<ol>
<caption>Три величины:</caption>
	<li>Время затраченное системой</li>
	<li>время затраченное на исполнение</li>
	<li>Общее время обслуживания, требующееся процессору (сколько времени требуется затратить на обработку процесса).</li>
</ol>

<ul> 
<caption>Режим решения подразделяют на две категории, в которой могут работать алгоритмя планирования </caption>
    <li>Вытесняющие</li>
    <li>Не вытесняющие (пока процессор полностью не обработает процесс, он 
никуда не уйдет)</li>
</ul>
<p>
<b>first Come, first served (FCFS)</b>- алгоритмы планирования - первый пришел первым обслужился.
Это невытесняющее планирование - процесс, получивший в свое распоряжение процессор, занимает его до истечения своего текущего
cpu burst(промежут времени непрерывного использования процессора).<br>
<b>I/O (input/output)</b>-промежуток ожидания ввода вывода</p>

<p>a=1<br>
b=2<br>
read c  cpu burst</p>

<p>ожидание <br>
ввода</p>

<p>a=a+c+b<br>
print</p>

<p>Время входа в систему<br>
Процесс<b> А </b>на<b> 5 </b>еденице<br>
Процесс<b> В </b>на 1 секунде<br>
Процесс<b> С </b>на<b> 3 </b>секунде</p>

<p><b>CPU:100,400,1,4 (процессы)</b></p>

<p>a=5<br>
b=1<br>
c=3</p>

<table>
<tr>
	<td>1</td>
	<td>2</td>
	<td>3</td>
	<td>4</td>
	<td>5</td>
	<td>6</td>
	<td>7</td>
	<td>8</td>
	<td>9</td>
</tr>

<tr>
	<td class="shtrih">1</td>
	<td class="shtrih">2</td>
	<td class="shtrih">3</td>
	<td>4</td>
	<td>5</td>
	<td>6</td>
	<td>7</td>
	<td>8</td>
	<td>9</td>
</tr>

<tr>
	<td>1</td>
	<td>2</td>
	<td>3</td>
	<td class="shtrih">4</td>
	<td class="shtrih">5</td>
	<td class="shtrih">6</td>
	<td class="shtrih">7</td>
	<td class="shtrih">8</td>
	<td>9</td>
</tr>

<tr>
	<td>1</td>
	<td>2</td>
	<td>3</td>
	<td>4</td>
	<td>5</td>
	<td>6</td>
	<td class="shtrih">7</td>
	<td>8</td>
	<td>9</td>
</tr>
</table>
<!--
1  2  3  4  5   6  7  8  9
_______
   3	_______________
		5
			___
			 7
 -->
 <ul> 
    <li><b>Преимущества</b> - простота реализации</li>
    <li><b>Недостатки</b>
		<ul> 
			<li>среднее время ожидания</li>
			<li>среднее время выполнения <br>
			зависят от порядка расположения процессов в очереди
при наличии процессов длительных машин, короткие процессы, которые пришли в состояние ожидания.
После рождения переходят в состояние готовности(исполнения).<br>
Короткие процессы будут ожидать состояния готовности.
Такой алгоритм не применим для систем разделения времени.			
			
			</li>
		
		</ul>
	</li>

</ul>


--
--



	<p>	<b>Алгоритм Round Robin(круглая карусель)</b>
процессы подсаживаются на некую карусель (рис.2) </p>
<p>
Рис. 2 <br>

<img alt="рисунок 2" src="img/2.png">
</p>
<p>
Пусть у нас есть процессы <span class="formula">p0, p1, p2</span><br>
Пусть<span class="formula"> p0 = 13</span><br>
      <span class="formula">p1 =4</span><br>
     <span class="formula"> p2=1</span> </p>
 <!--время  | 1  2  3  4  5   6  7  8  9  10   -->

<table>
<tr>
  <th>Время </th>
  
  <td>1</td>
  <td>2</td>
  <td>3</td>
  <td>4</td>
  <td>5</td>
  <td>6</td>
  <td>7</td>
  <td>8</td>
  <td>9</td>
  <td>10</td>
</tr>
</table>
<!--
P0	И  И  И  И  Г(4)

p1		      И  И  И  И  Г	

p2				    И  И  И  И -->


<table>
<tr>
<th></th>
	<th>1</th>
	<th>2</th>
	<th>3</th>
	<th>4</th>
	<th>5</th>
	<th>6</th>
	<th>7</th>
	<th>8</th>
	<th>9</th>
	<th>10</th>
</tr>
<tr>
   <th>p0</th>
   
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   
   <td></td>
   <td></td>
   <td></td>
   <td></td>
   <td></td>
   <td></td>
</tr>

<tr>
<th>p1</th>

<td></td>
   <td></td>
   <td></td>
   <td></td>
   
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">Г</td>
   <td></td>
   <td></td>
</tr>

<tr>
	<th>p2</th>
	
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	<td></td>
	
	<td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td class="shtrih">И</td>
   <td></td>
</tr>

</table>

<p><b>Round robin (4)</b></p>

<table>
<tr>
<th>Время </th> <td> 1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td>
</tr>
<tr>
<th>P0</th>	<td>И</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td> 
<td>Г</td><td>ГИ</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td>
</tr>
<tr>
<th>p1</th><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td>
<td>Г</td><td>Г</td><td>И</td><td>Г</td><td>Г</td>
</tr>
<tr>
<th>p2</th><td>Г</td><td>И</td><td>Г</td><td>Г</td><td>И</td><td>Г</td><td>ГИ</td><td>Г</td> 
<td>Г</td><td>И</td><td>Г</td><td>Г</td>
</tr>
</table>
<p><b>Round robin (1)</b></p>


<h1>Алгоритм (SJF) Shortest Job RR First</h1>
<p><b>Невытесняющий</b><br>
<!--
Время    | 1  2  3  4  5   6  7  8  9  10
P0

p1 Г Г Г Г И И И И И

p2 Г И И И

p3 Г Г Г Г Г Г Г Г Г -->
<table>
<tr>
<th>Время</th><td> 1</td> <td>2</td>  <td>3</td>  <td>4</td>  <td>5</td>
   <td>6</td>  <td>7</td>  <td>8</td>  <td>9</td>  <td>10</td>
</tr>
<tr>
<th>P0</th>
</tr>
<tr>
<th>p1</th> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>И</td> <td>И</td> <td>И</td> <td>И</td> <td>И</td>
</tr>
<tr>
<th>p2</th> <td>Г</td> <td>И</td> <td>И</td> <td>И</td>
</tr>
<tr>
<th>p3</th> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td> <td>Г</td>
</tr>
</table>

</p>
<p>
<b>Быстрый алгоритм</b><br>
При невытесняющем планировании процессор предоставляется избранному процессу на све требующееся ему время независимо от событий в системе.</p>


<p>
учитывается появление новых процессов во время выбранного процесса.<br>
Если cpu нового процесса меньше, чем остаток cpu burst исполняющегося, то испол. процесс вытесняется новым.</p>
<h2>Алгоритм работы первой момент появления в очереди</h2>
<table>
<tr>
 <th> (SJF)</th> <td>0</td>  <td>1</td> <td>2</td>  <td>3</td>  <td>4</td>  <td>5</td>   <td>6</td>  <td>7</td>  <td>8</td>  <td>9</td>  <td>10</td>
  </tr>
  <tr>
<th>P0</th> <td>6</td>  <td>5</td> <td>И</td> <td>Г</td> <td>Г</td> <td>Г</td>
</tr>
<tr>
<th>P1</th> <td>2</td>	<td>2</td>	      <td>И</td>  <td>И</td>
</tr>
<tr>
<th>P2</th> <td>5</td>	<td>8</td>
</tr>
<tr>
<th>P3</th> <td>5</td>	<td>0</td>		     <td>И</td> <td>И</td> <td>И</td> <td>И</td> <td>И</td>
</tr>
</table>
<p>
ТИ время нахождения И-того пользователя в системе<br>
Тау и-тое суммарное процессорное время процессов и-того пользователя<br>
Если тау и-тое меньше и-тое деленное на Н<br>
пользователь обделен<br>
если тау и-тое больше чем т и-тое деленное на н<br>
т-итое умноженное на н<br>
На исполнение выбираются готовые процессы пользователя с наименьшим коэффициентом справедливости. Такой алгоритм сложен</p>
<p>
3)<b>Алгоритм приоритетное планирование</b> - каждому процессу в  процессор
выделяется соответствие с приписынамым к нему числовым значением приоритетом. Параметры для назначения приоритета ббывают внешние и внутренние.</p>
<h1>Политика изменения приоритетов бывает : статическая и динамическая.</h1>

<p><b>Статический приоритет</b> - мы его назначили и неизменяем.</p>

<!--
	CPU	момент появления	Приоритет
P0	6		0		4	
P1	2		2		3
P2	5		6		2
P3	5		2		1
-->

<table>
<tr>
	<td>CPU	момент появления</td>	<td>Приоритет</td>
	</tr>
<tr>	
<th>P0</th>	<td>6</td>		<td>0</td>		<td>4</td>	
</tr>
<tr>
<th>P1</th>	<td>2</td>		<td>2</td>		<td>3</td>
</tr>
<tr>
<th>P2</th>	<td>5</td>		<td>6</td>		<td>2</td>
</tr>
<tr>
P3	5		2		1
</tr>

</table>


P0
P1	ИИ
P2	  ИИИИИ
P3ИИИИИ

Находится в состоянии готовности
многоуровневые очереди(multi level)
рис.3
---системные процессы с приоритетом 0 с алгоритмом Round Robin

---процессы преподавателя с приоритетом 2 с алгоритмом round robin

---фоновые процессы с приоритом 3 с алгоритом fcfs

---процессы студентом с приоритом 4 с алгоритмом rr

многоуровневые очереди с обратной связью
очередь, алгоритм, приоритет.
Каждый процесс будет в своей очереди.
Для полного описания требуют
Количество очередей в состоянии готовность
Должен быть общий алгоритм между очередями


алгоритмы планирования внутри очередей
Нужно задать куда поместить родившийся процесс и правила перевода процесса из одной очереди в другую


уровни планирования процессов
долгосрочное планирование - это планирование заданий
среднесрочное планирование - это swapping
краткосоровное планирование - это использование процессов


Цели планирования:
1)справедливость - гарантировать каждому заданию, каждому процессу некоторую часть процесса.

2)эффективность - 
3)сокращение полного времени выполнения general time

время от старта процесса до самого его завершения
4) сокращение времени ожидания
5) сокращение времени отклика (response time)

	Свойства алгоритмов планирования:
1)предсказуемость - одно и то же задание должно выполняться приблизительно за одно и то же время
2)минимальные накладные расходы - сокращение времени работы самого алгоритма планирования
3)сбалансированная загрузка ресурсов системы спреподчтением процессов, которые будут занимать малоиспользуемые ресурсы
4)маштабируемость

Домашнее задание :
нарисовать графики выполнения процессов по алгоритму по каждому алгоритму 

написать свою программу, которая это реализует.
fcfs
процессов четыре 

     
P0 7
P1 2
P2 9
P3 12
round robin с квантом времени (3)
SJF(невытесняющий)

SJF (3 0 1 2 )время выполнения
SJF (1 2 3 4)

продолжительность cpu 7 2 9 12

4) сокращение времени ожидания




</body>
</html>



